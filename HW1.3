#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_LINE 80

int main(void)
{
    char arg[MAX_LINE/2+1]; /*command line arguments*/
    int should_run = 1; /*flag to determine when to exit program*/
    char *argv[] = {"ls","-l",NULL};
    while(should_run){
        printf("osh>");
        fflush(stdout);
        
        /**
        * your code!
        * After reading user input, the step are:
        * (1) fork a child process using fork()
        * (2) the child process will invoke execvp()
        */
        
        read(0, arg, MAX_LINE);
        
        //if((char)arg[1] == 'e') return 0;
        //printf("%c",(char)arg[1]);
        
        if((char)arg[0] == 'c' && (char)arg[1] == 'a' && (char)arg[2] == 't'){
        
        }
        else if((char)arg[0] == 'l' && (char)arg[1] == 's'){
            pid_t pid = fork();
            if(pid == 0){
                execvp("ls", argv);
            }
            else if(pid > 0){
                wait(NULL);
            }
        }
        else if((char)arg[0] == 'd' && (char)arg[1] == 'a' && (char)arg[2] == 't' && (char)arg[3] == 'e'){
            pid_t pid = fork();
            if(pid == 0){
                execvp("date", argv);
            }
            else if(pid > 0){
                wait(NULL);
            }
        }
        else if((char)arg[0] == 'p' && (char)arg[1] == 's' && (char)arg[2] == ' ' && (char)arg[3] == '-' && (char)arg[4] == 'f'){
            pid_t pid = fork();
            if(pid == 0){
                execvp("ps -f", argv);
            }
            else if(pid > 0){
                wait(NULL);
            }
        }
        else if((char)arg[0] == 'e' && (char)arg[1] == 'x' && (char)arg[2] == 'i' && (char)arg[3] == 't'){
            //printf("exit\n");
            break;
        }
        else{
            printf("command not support\n");
        }
    }

    return 0;
}
